---
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 3
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# R jako GIS
Podpůrný text pro předmět: GIS pro biologické aplikace \
Autor: Matěj Man \
Aktualizace: 18. 11. 2019 \
Odkaz na R skript: [Kopírovat a vložit do R](http://labgis.ibot.cas.cz/gisproba/cv06_GIS_in_R_script.R)

#### Další zdroje: 
* Online kniha [Geocomputation with R](https://geocompr.robinlovelace.net/)
* Online kniha [Spatial Data Science with R](https://rspatial.org/raster/index.html)
* Velice pěkný návod pro [R knihovnu sf](https://r-spatial.github.io/sf/index.html)
* The Visual Raster Cheat Sheet [Rpubs dokument](http://www.rpubs.com/etiennebr/visualraster)



### Knihovny
```{r message=FALSE,warning=FALSE,results='hide'}
list.of.packages <- c("sf","raster","mapview","whitebox","randomcoloR","leaflet")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

library(sf)
library(raster)
library(mapview)
library(whitebox)
library(randomcoloR)
library(leaflet)
```


### Načítání vektorových GIS dat do R
```{r message=FALSE,warning=FALSE}
## Načítání vektorových dat shp
# nastavte kde máte u sebe na PC data
# pozor musíte zdvojit nebo otočit lomítka
cesta<-"D:\\GISPROBA\\cv_06" 
# zkonstuuje cestu kde leží vrstva Brdy
data.path<-paste0(cesta,"\\parky2\\CHKO_Brdy.shp")
# načte .shp do R
brdy<-st_read(data.path,stringsAsFactors = F,quiet = T)
# zobrazí načtený soubor v interkativním okně mapy
mapview(brdy)

# obdobně načteme třeba hranici ČR
data.path<-paste0(cesta,"\\hrcr1_wgs.shp")
hrcr<-st_read(data.path,stringsAsFactors = F,quiet = T)

# prostý obrázek, bez interaktivity
plot(st_geometry(hrcr)) 
# parametr add přidá další vrstvu do existujícího obrázku
plot(st_geometry(brdy),col="red",add=T) 

## Načítání vektorových dat z tabulky
# načíst prostou tabulku
chmu<-read.table("staniceCHMUtablecoma.csv",header = T, sep=",")
# převést tabulky na prostorová data
chmu_sf<-st_as_sf(chmu, coords = c("Xcoo", "Ycoo"),crs = 4326) 

## vizualizovat prostorová data interaktivně
# pokročilejší balíček leaflet

# definujeme paletu o 17 barvách podle typu stanice
distCol<- colorFactor(distinctColorPalette(17), chmu_sf$Station.ty)

# definoujeme okno s mapou 
leaflet(chmu_sf) %>% 
  addTiles() %>%  
  addCircleMarkers(popup=chmu_sf$Name,color = ~distCol(Station.ty),
                   stroke = FALSE, fillOpacity = 0.8,radius=4) %>%
  addLegend(pal = distCol, values = ~Station.ty)

```


### Načítání rastrových GIS dat do R
```{r message=FALSE,warning=FALSE}
# načítání jdnoduchou funkcí "raster"
DEM<-raster("DEM_Jested_100m.tif")
# kontrolí obrázek
plot(DEM)

# i rastr je možné vizualizovat interaktivně
# definujeme barvy
pal <- colorNumeric(c("#0C2C84", "#41B6C4", "#FFFFCC"), values(DEM),
  na.color = "transparent")

leaflet(DEM) %>% 
  addTiles() %>%  
  addRasterImage(DEM,colors = pal, opacity = 0.8) %>%
  addLegend(pal = pal, values = values(DEM),
            title = "Elevation [m]")

```


### Projekce a crs
```{r message=FALSE,warning=FALSE}

st_crs(brdy) # jaký crs má vrstva brdy ?
st_crs(hrcr) # jaký crs má vrstva hrnice čr ?
DEM@crs # jaký crs má digitální model ? 

## vektory
# transformace podle EPSG
brdy_32633<-st_transform(brdy, "+init=epsg:32633")
st_crs(brdy_32633) # jaký crs má vrstva brdy_32633 ?

# transformace podle proj4 string
brdy_5514<-st_transform(brdy, " +proj=krovak +lat_0=49.5 +lon_0=24.83333333333333 +k=0.9999 +x_0=0 +y_0=0 +ellps=bessel +towgs84=589,76,480,0,0,0,0 +units=m +no_defs ")
st_crs(brdy_5514) # jaký crs má vrstva brdy_5514 ?

# transformace podle jiné existující vrstvy
brdy_krovak<-st_transform(brdy, DEM@crs)
st_crs(brdy_krovak) # jaký crs má vrstva brdy_5514 ?

# kde jsou ty brdy? no nevidím je protože to má jiný CRS
plot(st_geometry(hrcr),main="Kde jsou ty Brdy?") 
plot(st_geometry(brdy_32633),add=T) 

# musíme tedy transformovat jedno nebo druhé
hrcr_32633<-st_transform(hrcr, "+init=epsg:32633")
plot(st_geometry(hrcr_32633),main="No jo, už máme správný CRS")
plot(st_geometry(brdy_32633),add=T,col="red")


## rastr
DEM@crs # jaký crs má digitální model ? 
DEM4326<-projectRaster(DEM, crs="+init=epsg:4326")
# Jak poznáme, že je raster projektovaný do jiného crs? 
par(mfrow=c(1,2))
plot(DEM4326)
plot(DEM)
```

### Příklad vektorové analýzy

```{r}
# plocha polygonů
st_area(brdy)

# délka linií (obvod polygonů)
st_length(brdy)

# buffer 5 km
brdy_5000<-st_buffer(brdy_32633,5000)
plot(st_geometry(brdy_5000), main="buffer 5 km")
plot(st_geometry(brdy_32633),add=T,col="red")

# centroidy
brdy_cen<-st_centroid(brdy_32633) 
plot(st_geometry(brdy_32633), main="centroid",graticule=T,axes=T)
plot(st_geometry(brdy_cen),add=T,col="blue",pch=19)

# průnik
chmu_brdy<-st_intersection(brdy,chmu_sf)
plot(st_geometry(brdy), main="intersection - chmu stanice v brdech",graticule=T,axes=T)
plot(st_geometry(chmu_brdy),add=T,col="red")

```


### Hromadné zpracování dat
#### Aneb co by nám v QGIS trvalo klikat hodiny můžeme v R naprogramovat během minut
```{r}
# načteme všechny cesty k shp vrstvám v daném adresáři
parky.files<-list.files(path=".\\parky2",pattern="*.shp$",full.names = T)

## když chceme všechny soubor do jednoho objektu
# načte první shpfile
parky.init<-st_read(parky.files[1],quiet = TRUE)

# připojí všechny další shp file do jendoho objektu  
for (i in 2:length(parky.files)) {
  parky.next<-st_read(parky.files[i],quiet = TRUE)
  parky.init<-rbind(parky.init,parky.next)
}  

# připojit metadat GIS join
meta.path<-paste0(cesta,"\\metadata_parky.csv")
metadata<-read.table(meta.path,sep=";",header=T,stringsAsFactors = T)
parky<-merge(parky.init,metadata)


# kontrolní obrázek
plot(st_geometry(hrcr))
plot(st_geometry(parky),add=T,col="green")

# interaktivně
distCol<- colorFactor(distinctColorPalette(32), parky.init$OBJECTID)
leaflet(parky) %>% 
  addTiles() %>%  
  addPolygons(color = ~distCol(OBJECTID),
              stroke = FALSE, fillOpacity = 0.8,
              label = paste0(parky$KAT,"_",parky$NAZEV))

```


### Rastrové analýzy
Velice dobrá knihovna pro rastrové analýzy v R je whitebox, což je implementace jinak v Python/Rust napsaných geo algoritmů.  

* [Homepage whitebox tools](https://jblindsay.github.io/ghrg/WhiteboxTools/index.html)
* [Manuál pro whitebox](https://jblindsay.github.io/wbt_book/preface.html)
* [Homepage r whitebox](https://github.com/giswqs/whiteboxR)


```{r}
# cesta k rastrovým datům
dem <- paste0(cesta,"\\DEM_Jested_100m.tif")
# vytvoří adresář pro výsledky
dir.create("vysledky") 

## stínovaný reliéf
# cesta k budoucímu výsledku
output<- paste0(cesta,"\\vysledky\\Hillshade_100m.tif")

# spustí algoitmus pro výpočet stinovaného reliéfu 
whitebox::hillshade(dem, output, azimuth = 315, altitude = 30, 
                    zfactor = 1,verbose_mode = FALSE)
# načtu výsledek jako rastr
hill<-raster(output)
# načtu původní dem jako rastr
elev<-raster(dem)
# vytisknu oba obrázky pro kontrolu
plot(hill, col=grey(0:100/100), legend=FALSE,main="stínovaný reliéf")
plot(elev, col=rainbow(25, alpha=0.35), add=TRUE)


## Sklon svahu
output<- paste0(cesta,"\\vysledky\\Slope_100m.tif")
whitebox::slope(dem,output,zfactor = 1, verbose_mode = FALSE)
slp<-raster(output)
plot(hill, col=grey(0:100/100), legend=FALSE,main="Sklon svahu")
plot(slp, col=heat.colors(25, alpha=0.2), add=TRUE)

## The terrain ruggedness index (TRI)
output<- paste0(cesta,"\\vysledky\\TRI_100m.tif")
whitebox::ruggedness_index(dem,output,zfactor = 1, verbose_mode = FALSE)
tri<-raster(output)
plot(hill, col=grey(0:100/100), legend=FALSE,main="terrain ruggedness index")
plot(tri, col=cm.colors(25, alpha=0.3), add=TRUE)


```



